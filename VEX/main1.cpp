#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  leftlift,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightlift,      sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           lmobile,       tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           rwheels,       tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port3,           lwheels,       tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port4,           ltlift,        tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port5,           rtlift,        tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port6,           lblift,        tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_5)
#pragma config(Motor,  port7,           rblift,        tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port8,           flip,          tmotorVex393_MC29, openLoop, encoderPort, I2C_6)
#pragma config(Motor,  port9,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rmobile,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define PIDC 5

int kp=50,ki=45,kd=60;
float lastE[10];
float lastI[10];
int target[10];
int pido[10];
int rpos[10];

int min(int a, int b){
	return a<b?a:b;
}

int max(int a, int b){
	return a>b?a:b;
}

int bound(int x, int a, int b){
	return max(a,min(x,b));
}

float updatePID(){
	for(int ch = 0; ch < PIDC; ch++){
		float cp, ci, cd, pidout;
		int tdiff = time1[T1];
		if(tdiff!=0){
			float et = target[ch]-rpos[ch];
			cp = et;
			//normalization
			cp /= 128;
			ci = lastI[ch] + (lastE[ch]+et)/2.0*tdiff;
			cd = (et-lastE[ch])/tdiff;

			lastE = cp;
			lastI = ci;
			pido[ch] = kp*cp + ki*ci + kd*cd;
			clearTimer(T1);
		}
	}
}

void liftControl(int pos){
	int pwn = 0;
	motor[rtlift] = pwn;
	motor[rblift] = pwn;
	motor[ltlift] = pwn;
	motor[lblift] = pwn;
}

void reset(){
	for(int i = 0; i < PIDC; i++){
		lastE[i] = 0.0;
		lastI[i] = 0.0;
	}
	nMotorEncoder[flip] = 0;
	nMotorEncoder[lmobile] = 0;
	nMotorEncoder[rblift] = 0;
	nMotorEncoder[lblift] = 0;
	ClearTimer(T1);
}

task main()
{
	int pwn2,pos = 0,posF = 0;
	reset();
	while(1){
		//motor[lwheels] = vexRT[Ch3];
  	//motor[rwheels] = vexRT[Ch2];

		pwn2 = vexRT[Ch2];
		motor[lmobile] = pwn2;
		motor[rmobile] = pwn2;
		//motor[lwheels] = vexRT[Ch3];
		//motor[rwheels] = vexRT[Ch1];
		if(vexRT[Btn7U]){
			motor[claw] = 128;
		}else if(vexRT[Btn7D]){
			motor[claw] = -128;
		}else{
			motor[claw] = 0;
		}

		//flip control
		motor[flip] = vexRT[Ch3];

		writeDebugStreamLine("Encoder pos:%d flip:%d", pos, nMotorEncoder[flip]);
	}


}
